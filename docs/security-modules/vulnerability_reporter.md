# Vulnerability Reporter Module Documentation

## Overview

The `vulnerability_reporter` module provides functions for generating customized vulnerability reports in various formats. Claude Code can orchestrate these functions to create reports tailored to different audiences and requirements.

## Report Generation Functions

### Executive Summary Functions

#### `generate_executive_summary(vulnerabilities: List[Dict[str, Any]], scan_metadata: Dict[str, Any] = None) -> str`

Generates a high-level executive summary suitable for business stakeholders.

**Parameters:**
- `vulnerabilities` (List[Dict]): List of vulnerability findings
- `scan_metadata` (Dict): Optional metadata (target, date, scan type)

**Returns:**
- Plain text executive summary

**Example:**
```python
metadata = {
    'target': '192.168.1.0/24',
    'scan_date': '2024-01-15',
    'scan_type': 'Quarterly Security Assessment'
}
summary = generate_executive_summary(vulnerabilities, metadata)
print(summary)
```

**Output includes:**
- Vulnerability counts by severity
- Overall risk score
- Top critical findings
- Key recommendations

**When to use:** Briefing management or non-technical stakeholders.

### Detailed Report Functions

#### `generate_detailed_findings(vulnerabilities: List[Dict[str, Any]], include_evidence: bool = True, group_by: str = 'severity') -> str`

Generates comprehensive technical findings report.

**Parameters:**
- `vulnerabilities` (List[Dict]): Vulnerability findings
- `include_evidence` (bool): Include technical evidence (default: True)
- `group_by` (str): Grouping method ('severity', 'service', 'type')

**Returns:**
- Detailed findings report in plain text

**Example:**
```python
# Group by service for targeted remediation
detailed = generate_detailed_findings(vulnerabilities, 
                                    include_evidence=True,
                                    group_by='service')
```

**When to use:** Technical teams needing full vulnerability details.

### Remediation Planning Functions

#### `generate_remediation_plan(vulnerabilities: List[Dict[str, Any]], timeline_days: int = 30) -> str`

Creates a prioritized remediation plan with timeline.

**Parameters:**
- `vulnerabilities` (List[Dict]): Vulnerability findings
- `timeline_days` (int): Total remediation timeline (default: 30 days)

**Returns:**
- Phased remediation plan with timeline

**Example:**
```python
# 90-day remediation plan
plan = generate_remediation_plan(vulnerabilities, timeline_days=90)
```

**Output includes:**
- Phase 1: Critical items (immediate)
- Phase 2: High priority (week 1-2)
- Phase 3: Medium priority (week 3-4)
- Phase 4: Low priority (remaining time)
- Effort estimates for each item

**When to use:** Planning remediation activities and resource allocation.

## Export Functions

### JSON Export

#### `export_as_json(vulnerabilities: List[Dict[str, Any]], metadata: Dict[str, Any] = None) -> str`

Exports vulnerabilities as JSON for integration with other tools.

**Parameters:**
- `vulnerabilities` (List[Dict]): Vulnerability findings
- `metadata` (Dict): Additional metadata to include

**Returns:**
- JSON formatted string

**Example:**
```python
json_report = export_as_json(vulnerabilities, {
    'scan_id': 'SEC-2024-001',
    'scanner': 'SuperSleuth',
    'version': '1.0'
})

# Save to file
with open('vulnerabilities.json', 'w') as f:
    f.write(json_report)
```

**When to use:** Integration with SIEM, ticketing systems, or databases.

### CSV Export

#### `export_as_csv(vulnerabilities: List[Dict[str, Any]]) -> str`

Exports vulnerabilities as CSV for spreadsheet analysis.

**Parameters:**
- `vulnerabilities` (List[Dict]): Vulnerability findings

**Returns:**
- CSV formatted string

**Example:**
```python
csv_report = export_as_csv(vulnerabilities)

# Save for Excel analysis
with open('vulnerabilities.csv', 'w') as f:
    f.write(csv_report)
```

**When to use:** Spreadsheet analysis, bulk updates, or imports.

### HTML Export

#### `export_as_html(vulnerabilities: List[Dict[str, Any]], metadata: Dict[str, Any] = None, include_charts: bool = True) -> str`

Generates an HTML report with optional visualizations.

**Parameters:**
- `vulnerabilities` (List[Dict]): Vulnerability findings
- `metadata` (Dict): Report metadata
- `include_charts` (bool): Include Chart.js visualizations (default: True)

**Returns:**
- Complete HTML document

**Example:**
```python
html_report = export_as_html(vulnerabilities, 
                            metadata={'target': 'Production Network'},
                            include_charts=True)

# Save as web report
with open('security_report.html', 'w') as f:
    f.write(html_report)
```

**Features:**
- Severity-based color coding
- Interactive charts (if enabled)
- Sortable tables
- Professional styling

**When to use:** Presentations, web portals, or email reports.

## Analysis Functions

### Risk Calculation

#### `calculate_overall_risk(vulnerabilities: List[Dict[str, Any]]) -> Dict[str, Any]`

Calculates aggregate risk score from all vulnerabilities.

**Parameters:**
- `vulnerabilities` (List[Dict]): Vulnerability findings

**Returns:**
- Dictionary with:
  - `score`: Risk score (0-10)
  - `level`: 'CRITICAL', 'HIGH', 'MEDIUM', or 'LOW'
  - `total_weighted`: Raw weighted score

**Example:**
```python
risk = calculate_overall_risk(vulnerabilities)
print(f"Overall Risk: {risk['level']} ({risk['score']}/10)")
```

**When to use:** Executive dashboards or risk metrics.

### Recommendation Generation

#### `generate_prioritized_recommendations(vulnerabilities: List[Dict[str, Any]]) -> List[str]`

Generates actionable recommendations based on findings.

**Parameters:**
- `vulnerabilities` (List[Dict]): Vulnerability findings

**Returns:**
- List of prioritized recommendations

**Example:**
```python
recommendations = generate_prioritized_recommendations(vulnerabilities)
for i, rec in enumerate(recommendations[:5], 1):
    print(f"{i}. {rec}")
```

**When to use:** Action items for remediation teams.

### Vulnerability Prioritization

#### `prioritize_vulnerabilities(vulnerabilities: List[Dict[str, Any]]) -> List[Dict[str, Any]]`

Adds priority field based on severity and impact.

**Parameters:**
- `vulnerabilities` (List[Dict]): Vulnerability findings

**Returns:**
- Vulnerabilities with added 'priority' field:
  - 'immediate': Critical issues
  - 'high': High priority
  - 'medium': Medium priority
  - 'low': Low priority

**Example:**
```python
prioritized = prioritize_vulnerabilities(vulnerabilities)
immediate = [v for v in prioritized if v['priority'] == 'immediate']
print(f"Immediate action required: {len(immediate)} vulnerabilities")
```

**When to use:** Resource allocation and planning.

## Comparison Functions

#### `compare_scan_results(previous: List[Dict[str, Any]], current: List[Dict[str, Any]]) -> Dict[str, List[Dict[str, Any]]]`

Compares two scan results to track changes.

**Parameters:**
- `previous` (List[Dict]): Previous scan vulnerabilities
- `current` (List[Dict]): Current scan vulnerabilities

**Returns:**
- Dictionary with:
  - `new`: Newly discovered vulnerabilities
  - `fixed`: Resolved vulnerabilities
  - `persistent`: Ongoing vulnerabilities
  - `summary`: Statistical summary

**Example:**
```python
comparison = compare_scan_results(last_month_vulns, current_vulns)
print(f"New vulnerabilities: {len(comparison['new'])}")
print(f"Fixed since last scan: {len(comparison['fixed'])}")
```

**When to use:** Progress tracking and trend analysis.

## Common Report Workflows

### Workflow 1: Executive Briefing
```python
# Quick executive report
def create_executive_briefing(vulnerabilities, target):
    metadata = {
        'target': target,
        'scan_date': datetime.now().strftime('%Y-%m-%d')
    }
    
    # Generate summary
    summary = generate_executive_summary(vulnerabilities, metadata)
    
    # Add risk score
    risk = calculate_overall_risk(vulnerabilities)
    
    # Get top recommendations
    recommendations = generate_prioritized_recommendations(vulnerabilities)
    
    return f"{summary}\n\nRisk Level: {risk['level']}\n\nTop Actions:\n" + \
           "\n".join(f"- {r}" for r in recommendations[:3])
```

### Workflow 2: Technical Deep Dive
```python
# Comprehensive technical report
def create_technical_report(vulnerabilities):
    # Group by service for engineering teams
    detailed = generate_detailed_findings(vulnerabilities, 
                                        include_evidence=True,
                                        group_by='service')
    
    # Add remediation timeline
    plan = generate_remediation_plan(vulnerabilities, timeline_days=30)
    
    # Export data for tracking
    json_data = export_as_json(vulnerabilities)
    
    return {
        'detailed_findings': detailed,
        'remediation_plan': plan,
        'data_export': json_data
    }
```

### Workflow 3: Compliance Report
```python
# Compliance-focused reporting
def create_compliance_report(vulnerabilities, framework='PCI DSS'):
    # Filter critical/high only
    high_risk = [v for v in vulnerabilities 
                 if v.get('severity') in ['CRITICAL', 'HIGH']]
    
    # Generate HTML with charts
    html = export_as_html(high_risk, 
                         metadata={'compliance': framework},
                         include_charts=True)
    
    # Create remediation plan
    plan = generate_remediation_plan(high_risk, timeline_days=90)
    
    return {
        'html_report': html,
        'remediation_plan': plan,
        'critical_count': len(high_risk)
    }
```

## Output Formatting

### Text Reports
- Clear hierarchical structure
- Severity-based sections
- Bullet points for readability
- Executive summary at top

### HTML Reports
- Professional styling
- Color-coded severity
- Interactive elements
- Print-friendly CSS

### Data Exports
- Standard field names
- Consistent date formats
- Nested data handling
- UTF-8 encoding

## Best Practices

1. **Audience Awareness**: Choose format based on recipient
   - Executives: Summary + risk score
   - Engineers: Detailed + evidence
   - Compliance: Formal + structured

2. **Consistent Formatting**: Use the same report format for trending

3. **Action-Oriented**: Always include recommendations

4. **Visual Elements**: Use HTML reports for presentations

5. **Data Preservation**: Export JSON for long-term storage

## Integration with Other Modules

The reporter integrates with:
- **Security Scanner**: Formats scan results
- **CVE Database**: Enriches vulnerability details
- **Security Assessment**: Provides report generation for assessments

## Performance Considerations

- Large reports (1000+ vulnerabilities) may take time to generate
- HTML charts require browser JavaScript support
- CSV exports handle nested data by flattening

## Error Handling

All functions handle:
- Empty vulnerability lists
- Missing fields in vulnerability data
- Invalid grouping options
- Character encoding issues

Functions return empty reports rather than failing.