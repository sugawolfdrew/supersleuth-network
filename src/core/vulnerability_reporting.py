"""
Vulnerability Risk Scoring and Reporting System

This module provides comprehensive risk scoring algorithms and multi-format reporting
capabilities for vulnerability findings, designed for Claude Code orchestration.
"""

import json
import csv
from typing import Dict, List, Optional, Any, Union
from datetime import datetime
import io
from collections import defaultdict
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np

from ..diagnostics.cve_database import calculate_risk_score as calculate_cve_risk
from ..utils.logger import get_logger

logger = get_logger(__name__)


class RiskScorer:
    """
    Advanced risk scoring system with environmental and temporal factors.
    """
    
    def __init__(self):
        self.base_weights = {
            'cvss_score': 0.35,
            'exploitability': 0.25,
            'asset_criticality': 0.20,
            'exposure': 0.10,
            'temporal': 0.10
        }
        
    def calculate_risk_score(self, vulnerability: Dict, 
                           asset_info: Dict = None,
                           environment_info: Dict = None) -> Dict[str, Any]:
        """
        Calculate comprehensive risk score for a vulnerability.
        
        Args:
            vulnerability: Vulnerability information
            asset_info: Asset criticality and classification
            environment_info: Environmental factors
            
        Returns:
            dict: Risk score with detailed breakdown
        """
        # Base CVSS score
        cvss_score = vulnerability.get('cvss_score', 0)
        if not cvss_score:
            # Try alternative fields
            cvss_score = vulnerability.get('cvss_v3_score') or vulnerability.get('cvss_base', 0)
            
        # Exploitability factors
        exploitability_score = self._calculate_exploitability(vulnerability)
        
        # Asset criticality (default to medium if not provided)
        asset_criticality = 5
        if asset_info:
            asset_criticality = asset_info.get('criticality', 5)
            
        # Exposure level
        exposure = self._calculate_exposure(vulnerability, environment_info)
        
        # Temporal score (age of vulnerability)
        temporal_score = self._calculate_temporal_score(vulnerability)
        
        # Calculate weighted risk score
        risk_components = {
            'cvss_score': cvss_score / 10,  # Normalize to 0-1
            'exploitability': exploitability_score,
            'asset_criticality': asset_criticality / 10,
            'exposure': exposure / 10,
            'temporal': temporal_score
        }
        
        # Apply weights
        weighted_score = sum(
            risk_components[factor] * self.base_weights[factor]
            for factor in risk_components
        )
        
        # Scale to 0-100
        risk_score = round(weighted_score * 100, 2)
        
        # Determine risk level
        if risk_score >= 90:
            risk_level = 'CRITICAL'
        elif risk_score >= 70:
            risk_level = 'HIGH'
        elif risk_score >= 40:
            risk_level = 'MEDIUM'
        elif risk_score >= 10:
            risk_level = 'LOW'
        else:
            risk_level = 'INFO'
            
        return {
            'risk_score': risk_score,
            'risk_level': risk_level,
            'components': risk_components,
            'recommendations': self._generate_recommendations(risk_level, vulnerability),
            'remediation_priority': self._calculate_remediation_priority(risk_score, vulnerability)
        }
        
    def _calculate_exploitability(self, vulnerability: Dict) -> float:
        """Calculate exploitability score (0-1)."""
        score = 0.0
        
        # Check for known exploits
        if vulnerability.get('exploit_available'):
            score += 0.5
            
        # Check exploit ease
        exploit_ease = vulnerability.get('exploitability_ease', '').lower()
        if 'no exploit' in exploit_ease:
            score += 0.0
        elif 'poc' in exploit_ease:
            score += 0.3
        elif 'functional' in exploit_ease:
            score += 0.4
        elif 'high' in exploit_ease:
            score += 0.5
            
        # Check if in CISA KEV or similar
        if 'actively exploited' in vulnerability.get('description', '').lower():
            score = 1.0
            
        return min(1.0, score)
        
    def _calculate_exposure(self, vulnerability: Dict, environment_info: Dict) -> float:
        """Calculate exposure level (0-10)."""
        exposure = 5.0  # Default medium exposure
        
        if not environment_info:
            return exposure
            
        # Check if exposed to internet
        if environment_info.get('internet_facing'):
            exposure += 3.0
            
        # Check network segmentation
        if environment_info.get('segmented'):
            exposure -= 2.0
            
        # Check access controls
        if environment_info.get('access_controlled'):
            exposure -= 1.0
            
        return max(0, min(10, exposure))
        
    def _calculate_temporal_score(self, vulnerability: Dict) -> float:
        """Calculate temporal score based on vulnerability age (0-1)."""
        try:
            # Get publication date
            pub_date_str = vulnerability.get('published_date') or vulnerability.get('first_found')
            if not pub_date_str:
                return 0.5  # Unknown age
                
            # Parse date
            if 'T' in pub_date_str:
                pub_date = datetime.fromisoformat(pub_date_str.replace('Z', '+00:00'))
            else:
                pub_date = datetime.strptime(pub_date_str, '%Y-%m-%d')
                
            # Calculate age in days
            age_days = (datetime.now() - pub_date).days
            
            # Score based on age
            if age_days < 30:
                return 1.0  # Very new, high risk
            elif age_days < 90:
                return 0.8
            elif age_days < 365:
                return 0.6
            elif age_days < 730:
                return 0.4
            else:
                return 0.2  # Old vulnerability
                
        except Exception as e:
            logger.error(f"Error calculating temporal score: {e}")
            return 0.5
            
    def _generate_recommendations(self, risk_level: str, vulnerability: Dict) -> List[str]:
        """Generate remediation recommendations based on risk level."""
        recommendations = []
        
        if risk_level == 'CRITICAL':
            recommendations.extend([
                "Patch immediately or implement compensating controls within 24 hours",
                "Isolate affected systems if patching is not immediately possible",
                "Monitor for exploitation attempts",
                "Conduct forensic analysis to check for past exploitation"
            ])
        elif risk_level == 'HIGH':
            recommendations.extend([
                "Patch within 7 days",
                "Implement network segmentation if not already in place",
                "Enable enhanced monitoring on affected systems",
                "Review access controls and minimize exposure"
            ])
        elif risk_level == 'MEDIUM':
            recommendations.extend([
                "Patch within 30 days during maintenance window",
                "Monitor vendor advisories for updates",
                "Ensure proper access controls are in place"
            ])
        else:
            recommendations.extend([
                "Patch during next scheduled maintenance",
                "Continue standard monitoring practices"
            ])
            
        # Add specific recommendations based on vulnerability type
        if vulnerability.get('solution'):
            recommendations.insert(0, f"Vendor recommendation: {vulnerability['solution'][:200]}...")
            
        return recommendations
        
    def _calculate_remediation_priority(self, risk_score: float, vulnerability: Dict) -> int:
        """Calculate remediation priority (1-5, 1 being highest)."""
        # Start with risk-based priority
        if risk_score >= 90:
            priority = 1
        elif risk_score >= 70:
            priority = 2
        elif risk_score >= 40:
            priority = 3
        elif risk_score >= 10:
            priority = 4
        else:
            priority = 5
            
        # Adjust based on other factors
        if vulnerability.get('exploit_available'):
            priority = max(1, priority - 1)
            
        # Critical services get higher priority
        port = vulnerability.get('port', 0)
        critical_ports = [22, 23, 3389, 445, 1433, 3306, 5432, 80, 443]
        if port in critical_ports:
            priority = max(1, priority - 1)
            
        return priority


class VulnerabilityReporter:
    """
    Multi-format vulnerability reporting system.
    """
    
    def __init__(self):
        self.risk_scorer = RiskScorer()
        
    def generate_report(self, vulnerabilities: List[Dict],
                       report_format: str = 'json',
                       report_options: Dict = None) -> Union[Dict, str, bytes]:
        """
        Generate vulnerability report in specified format.
        
        Args:
            vulnerabilities: List of vulnerabilities to report
            report_format: Format (json, csv, pdf, html, executive)
            report_options: Format-specific options
            
        Returns:
            Report in requested format
        """
        if report_options is None:
            report_options = {}
            
        # Add risk scores to vulnerabilities
        scored_vulns = self._score_vulnerabilities(vulnerabilities, report_options)
        
        # Generate report based on format
        if report_format == 'json':
            return self._generate_json_report(scored_vulns, report_options)
        elif report_format == 'csv':
            return self._generate_csv_report(scored_vulns, report_options)
        elif report_format == 'pdf':
            return self._generate_pdf_report(scored_vulns, report_options)
        elif report_format == 'html':
            return self._generate_html_report(scored_vulns, report_options)
        elif report_format == 'executive':
            return self._generate_executive_report(scored_vulns, report_options)
        else:
            raise ValueError(f"Unsupported report format: {report_format}")
            
    def _score_vulnerabilities(self, vulnerabilities: List[Dict],
                             options: Dict) -> List[Dict]:
        """Add risk scores to all vulnerabilities."""
        scored = []
        
        asset_info = options.get('asset_info', {})
        environment_info = options.get('environment_info', {})
        
        for vuln in vulnerabilities:
            # Get asset-specific info if available
            host = vuln.get('host')
            asset_data = asset_info.get(host, {})
            
            # Calculate risk score
            risk_data = self.risk_scorer.calculate_risk_score(
                vuln, asset_data, environment_info
            )
            
            # Add risk data to vulnerability
            scored_vuln = vuln.copy()
            scored_vuln['risk_assessment'] = risk_data
            scored.append(scored_vuln)
            
        # Sort by risk priority
        scored.sort(key=lambda x: x['risk_assessment']['remediation_priority'])
        
        return scored
        
    def _generate_json_report(self, vulnerabilities: List[Dict],
                            options: Dict) -> Dict[str, Any]:
        """Generate JSON format report."""
        report = {
            'report_metadata': {
                'generated_at': datetime.now().isoformat(),
                'total_vulnerabilities': len(vulnerabilities),
                'report_format': 'json',
                'version': '1.0'
            },
            'summary': self._generate_summary(vulnerabilities),
            'vulnerabilities': vulnerabilities,
            'statistics': self._generate_statistics(vulnerabilities),
            'trends': self._analyze_trends(vulnerabilities)
        }
        
        if options.get('include_recommendations'):
            report['recommendations'] = self._generate_overall_recommendations(vulnerabilities)
            
        return report
        
    def _generate_csv_report(self, vulnerabilities: List[Dict],
                           options: Dict) -> str:
        """Generate CSV format report."""
        output = io.StringIO()
        
        # Define fields to include
        fields = [
            'host', 'port', 'vulnerability_id', 'name', 'severity',
            'cvss_score', 'risk_score', 'risk_level', 'remediation_priority',
            'cve', 'solution', 'detected_by'
        ]
        
        writer = csv.DictWriter(output, fieldnames=fields, extrasaction='ignore')
        writer.writeheader()
        
        for vuln in vulnerabilities:
            row = vuln.copy()
            
            # Flatten nested fields
            risk_data = vuln.get('risk_assessment', {})
            row['risk_score'] = risk_data.get('risk_score')
            row['risk_level'] = risk_data.get('risk_level')
            row['remediation_priority'] = risk_data.get('remediation_priority')
            
            # Convert lists to strings
            if isinstance(row.get('cve'), list):
                row['cve'] = ', '.join(row['cve'])
            if isinstance(row.get('detected_by'), list):
                row['detected_by'] = ', '.join(row['detected_by'])
                
            writer.writerow(row)
            
        return output.getvalue()
        
    def _generate_pdf_report(self, vulnerabilities: List[Dict],
                           options: Dict) -> bytes:
        """Generate PDF format report with charts."""
        pdf_buffer = io.BytesIO()
        
        with PdfPages(pdf_buffer) as pdf:
            # Title page
            self._create_title_page(pdf, vulnerabilities, options)
            
            # Executive summary
            self._create_executive_summary_page(pdf, vulnerabilities)
            
            # Statistics and charts
            self._create_statistics_pages(pdf, vulnerabilities)
            
            # Detailed findings
            self._create_detailed_findings_pages(pdf, vulnerabilities)
            
            # Recommendations
            self._create_recommendations_page(pdf, vulnerabilities)
            
        pdf_buffer.seek(0)
        return pdf_buffer.read()
        
    def _generate_html_report(self, vulnerabilities: List[Dict],
                            options: Dict) -> str:
        """Generate HTML format report."""
        summary = self._generate_summary(vulnerabilities)
        stats = self._generate_statistics(vulnerabilities)
        
        html = f"""
<!DOCTYPE html>
<html>
<head>
    <title>Vulnerability Assessment Report</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 20px; }}
        table {{ border-collapse: collapse; width: 100%; margin-top: 20px; }}
        th, td {{ border: 1px solid #ddd; padding: 8px; text-align: left; }}
        th {{ background-color: #f2f2f2; }}
        .critical {{ background-color: #ff4444; color: white; }}
        .high {{ background-color: #ff8844; }}
        .medium {{ background-color: #ffaa44; }}
        .low {{ background-color: #ffdd44; }}
        .info {{ background-color: #f0f0f0; }}
        .summary-box {{ background-color: #f9f9f9; padding: 15px; margin: 20px 0; border-radius: 5px; }}
    </style>
</head>
<body>
    <h1>Vulnerability Assessment Report</h1>
    <p>Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
    
    <div class="summary-box">
        <h2>Executive Summary</h2>
        <p>Total Vulnerabilities: {summary['total_vulnerabilities']}</p>
        <ul>
            <li>Critical: {summary['by_severity']['critical']}</li>
            <li>High: {summary['by_severity']['high']}</li>
            <li>Medium: {summary['by_severity']['medium']}</li>
            <li>Low: {summary['by_severity']['low']}</li>
            <li>Info: {summary['by_severity']['info']}</li>
        </ul>
        <p>Affected Hosts: {summary['hosts_affected']}</p>
    </div>
    
    <h2>Risk Distribution</h2>
    <table>
        <tr>
            <th>Risk Level</th>
            <th>Count</th>
            <th>Percentage</th>
        </tr>
"""
        
        # Add risk distribution
        total = summary['total_vulnerabilities']
        for level, count in summary['by_risk_level'].items():
            percentage = (count / total * 100) if total > 0 else 0
            html += f"""
        <tr>
            <td class="{level.lower()}">{level}</td>
            <td>{count}</td>
            <td>{percentage:.1f}%</td>
        </tr>
"""
        
        html += """
    </table>
    
    <h2>Detailed Findings</h2>
    <table>
        <tr>
            <th>Host</th>
            <th>Port</th>
            <th>Vulnerability</th>
            <th>Severity</th>
            <th>Risk Score</th>
            <th>Priority</th>
            <th>CVE</th>
        </tr>
"""
        
        # Add vulnerability details
        for vuln in vulnerabilities[:100]:  # Limit to first 100
            risk_data = vuln.get('risk_assessment', {})
            cves = vuln.get('cve', [])
            cve_str = ', '.join(cves[:3]) if isinstance(cves, list) else str(cves)
            
            html += f"""
        <tr>
            <td>{vuln.get('host', 'N/A')}</td>
            <td>{vuln.get('port', 'N/A')}</td>
            <td>{vuln.get('name', 'Unknown')[:100]}...</td>
            <td class="{vuln.get('severity', '').lower()}">{vuln.get('severity', 'N/A')}</td>
            <td>{risk_data.get('risk_score', 'N/A')}</td>
            <td>{risk_data.get('remediation_priority', 'N/A')}</td>
            <td>{cve_str}</td>
        </tr>
"""
        
        html += """
    </table>
    
    <p><em>Report limited to first 100 vulnerabilities for performance.</em></p>
</body>
</html>
"""
        return html
        
    def _generate_executive_report(self, vulnerabilities: List[Dict],
                                 options: Dict) -> Dict[str, Any]:
        """Generate executive-level summary report."""
        summary = self._generate_summary(vulnerabilities)
        
        # Calculate business impact metrics
        critical_systems = set()
        for vuln in vulnerabilities:
            if vuln.get('risk_assessment', {}).get('risk_level') in ['CRITICAL', 'HIGH']:
                critical_systems.add(vuln.get('host'))
                
        # Estimate remediation effort
        total_effort_hours = 0
        for vuln in vulnerabilities:
            priority = vuln.get('risk_assessment', {}).get('remediation_priority', 5)
            # Rough estimate: priority 1 = 4 hours, priority 2 = 2 hours, etc.
            effort_hours = max(1, 5 - priority) * 2
            total_effort_hours += effort_hours
            
        return {
            'executive_summary': {
                'assessment_date': datetime.now().isoformat(),
                'overall_risk_level': self._calculate_overall_risk(summary),
                'critical_findings': summary['by_severity']['critical'],
                'systems_at_risk': len(critical_systems),
                'estimated_remediation_effort': f"{total_effort_hours} hours",
                'key_recommendations': [
                    f"Address {summary['by_severity']['critical']} critical vulnerabilities immediately",
                    f"Implement patching for {summary['by_severity']['high']} high-risk vulnerabilities within 7 days",
                    f"Review security controls on {len(critical_systems)} critical systems",
                    "Establish regular vulnerability scanning schedule"
                ]
            },
            'risk_metrics': {
                'total_vulnerabilities': summary['total_vulnerabilities'],
                'risk_distribution': summary['by_risk_level'],
                'affected_systems': summary['hosts_affected'],
                'compliance_impact': self._assess_compliance_impact(vulnerabilities)
            },
            'business_impact': {
                'potential_downtime': f"{summary['by_severity']['critical'] * 4} hours",
                'data_breach_risk': 'High' if summary['by_severity']['critical'] > 0 else 'Medium',
                'regulatory_exposure': self._assess_regulatory_exposure(vulnerabilities)
            },
            'action_plan': self._generate_action_plan(summary, vulnerabilities)
        }
        
    def _generate_summary(self, vulnerabilities: List[Dict]) -> Dict[str, Any]:
        """Generate summary statistics."""
        severity_counts = defaultdict(int)
        risk_counts = defaultdict(int)
        hosts = set()
        
        for vuln in vulnerabilities:
            # Count by severity
            severity = vuln.get('severity', 'UNKNOWN')
            if isinstance(severity, str):
                severity_counts[severity.lower()] += 1
            
            # Count by risk level
            risk_level = vuln.get('risk_assessment', {}).get('risk_level', 'UNKNOWN')
            risk_counts[risk_level] += 1
            
            # Collect unique hosts
            hosts.add(vuln.get('host'))
            
        return {
            'total_vulnerabilities': len(vulnerabilities),
            'by_severity': dict(severity_counts),
            'by_risk_level': dict(risk_counts),
            'hosts_affected': len(hosts)
        }
        
    def _generate_statistics(self, vulnerabilities: List[Dict]) -> Dict[str, Any]:
        """Generate detailed statistics."""
        stats = {
            'cvss_distribution': defaultdict(int),
            'top_vulnerable_services': defaultdict(int),
            'vulnerability_age': defaultdict(int),
            'detection_methods': defaultdict(int)
        }
        
        for vuln in vulnerabilities:
            # CVSS distribution
            cvss = vuln.get('cvss_score', 0)
            if cvss >= 9:
                stats['cvss_distribution']['9-10'] += 1
            elif cvss >= 7:
                stats['cvss_distribution']['7-9'] += 1
            elif cvss >= 4:
                stats['cvss_distribution']['4-7'] += 1
            else:
                stats['cvss_distribution']['0-4'] += 1
                
            # Top services
            port = vuln.get('port', 'unknown')
            stats['top_vulnerable_services'][f"port_{port}"] += 1
            
            # Detection methods
            detected_by = vuln.get('detected_by', ['unknown'])
            if isinstance(detected_by, list):
                for scanner in detected_by:
                    stats['detection_methods'][scanner] += 1
                    
        return dict(stats)
        
    def _analyze_trends(self, vulnerabilities: List[Dict]) -> Dict[str, Any]:
        """Analyze vulnerability trends."""
        trends = {
            'most_common_cves': defaultdict(int),
            'trending_vulnerabilities': [],
            'patch_age_analysis': {}
        }
        
        # Count CVEs
        for vuln in vulnerabilities:
            cves = vuln.get('cve', [])
            if isinstance(cves, list):
                for cve in cves:
                    trends['most_common_cves'][cve] += 1
                    
        # Get top 10 most common CVEs
        top_cves = sorted(trends['most_common_cves'].items(), 
                         key=lambda x: x[1], reverse=True)[:10]
        trends['most_common_cves'] = dict(top_cves)
        
        return trends
        
    def _generate_overall_recommendations(self, vulnerabilities: List[Dict]) -> List[Dict]:
        """Generate prioritized recommendations."""
        recommendations = []
        
        # Group by remediation priority
        priority_groups = defaultdict(list)
        for vuln in vulnerabilities:
            priority = vuln.get('risk_assessment', {}).get('remediation_priority', 5)
            priority_groups[priority].append(vuln)
            
        # Generate recommendations for each priority level
        for priority in sorted(priority_groups.keys()):
            vulns = priority_groups[priority]
            
            if priority == 1:
                recommendations.append({
                    'priority': 'IMMEDIATE',
                    'timeframe': '24 hours',
                    'actions': [
                        f"Patch {len(vulns)} critical vulnerabilities",
                        "Implement emergency change control if needed",
                        "Monitor for active exploitation"
                    ],
                    'affected_systems': len(set(v.get('host') for v in vulns))
                })
            elif priority == 2:
                recommendations.append({
                    'priority': 'HIGH',
                    'timeframe': '7 days',
                    'actions': [
                        f"Schedule patching for {len(vulns)} high-priority vulnerabilities",
                        "Implement compensating controls where patching is delayed",
                        "Review network segmentation"
                    ],
                    'affected_systems': len(set(v.get('host') for v in vulns))
                })
                
        return recommendations
        
    def _calculate_overall_risk(self, summary: Dict) -> str:
        """Calculate overall risk level."""
        if summary['by_severity'].get('critical', 0) > 0:
            return 'CRITICAL'
        elif summary['by_severity'].get('high', 0) > 5:
            return 'HIGH'
        elif summary['by_severity'].get('medium', 0) > 20:
            return 'MEDIUM'
        else:
            return 'LOW'
            
    def _assess_compliance_impact(self, vulnerabilities: List[Dict]) -> Dict[str, str]:
        """Assess impact on compliance requirements."""
        compliance_impact = {
            'pci_dss': 'Low',
            'hipaa': 'Low',
            'sox': 'Low'
        }
        
        # Check for specific compliance-relevant vulnerabilities
        for vuln in vulnerabilities:
            if vuln.get('risk_assessment', {}).get('risk_level') in ['CRITICAL', 'HIGH']:
                # Database vulnerabilities affect SOX
                if vuln.get('port') in [1433, 3306, 5432]:
                    compliance_impact['sox'] = 'High'
                    
                # Any critical vulnerability affects PCI DSS
                compliance_impact['pci_dss'] = 'High'
                
                # Healthcare systems
                if 'health' in vuln.get('host', '').lower():
                    compliance_impact['hipaa'] = 'High'
                    
        return compliance_impact
        
    def _assess_regulatory_exposure(self, vulnerabilities: List[Dict]) -> str:
        """Assess regulatory exposure level."""
        critical_count = sum(1 for v in vulnerabilities 
                           if v.get('risk_assessment', {}).get('risk_level') == 'CRITICAL')
        
        if critical_count > 10:
            return 'Severe - Immediate regulatory risk'
        elif critical_count > 5:
            return 'High - Potential for regulatory action'
        elif critical_count > 0:
            return 'Medium - Regulatory scrutiny possible'
        else:
            return 'Low - Standard compliance requirements'
            
    def _generate_action_plan(self, summary: Dict, vulnerabilities: List[Dict]) -> List[Dict]:
        """Generate phased action plan."""
        return [
            {
                'phase': 'Immediate (0-24 hours)',
                'actions': [
                    'Isolate systems with critical vulnerabilities',
                    'Apply emergency patches for exploitable vulnerabilities',
                    'Enable enhanced monitoring and logging'
                ]
            },
            {
                'phase': 'Short-term (1-7 days)',
                'actions': [
                    'Complete patching of all critical vulnerabilities',
                    'Implement network segmentation improvements',
                    'Conduct validation testing'
                ]
            },
            {
                'phase': 'Medium-term (1-4 weeks)',
                'actions': [
                    'Address all high and medium vulnerabilities',
                    'Update security policies and procedures',
                    'Implement automated patch management'
                ]
            },
            {
                'phase': 'Long-term (1-3 months)',
                'actions': [
                    'Establish continuous vulnerability management program',
                    'Implement security awareness training',
                    'Deploy advanced threat detection'
                ]
            }
        ]
        
    # PDF generation helper methods
    def _create_title_page(self, pdf, vulnerabilities, options):
        """Create PDF title page."""
        fig, ax = plt.subplots(figsize=(8.5, 11))
        ax.axis('off')
        
        # Title
        ax.text(0.5, 0.8, 'Vulnerability Assessment Report', 
                ha='center', va='center', fontsize=24, fontweight='bold')
        
        # Client info if provided
        if options.get('client_name'):
            ax.text(0.5, 0.7, options['client_name'],
                   ha='center', va='center', fontsize=18)
                   
        # Date
        ax.text(0.5, 0.6, datetime.now().strftime('%B %d, %Y'),
               ha='center', va='center', fontsize=14)
               
        # Summary box
        summary = self._generate_summary(vulnerabilities)
        summary_text = f"""
Total Vulnerabilities: {summary['total_vulnerabilities']}
Critical: {summary['by_severity'].get('critical', 0)}
High: {summary['by_severity'].get('high', 0)}
Affected Systems: {summary['hosts_affected']}
"""
        ax.text(0.5, 0.4, summary_text, ha='center', va='center',
               fontsize=12, bbox=dict(boxstyle="round,pad=0.5", facecolor="lightgray"))
               
        pdf.savefig(fig)
        plt.close(fig)
        
    def _create_executive_summary_page(self, pdf, vulnerabilities):
        """Create executive summary page for PDF."""
        fig, ax = plt.subplots(figsize=(8.5, 11))
        ax.axis('off')
        
        # Title
        ax.text(0.5, 0.95, 'Executive Summary', 
                ha='center', va='top', fontsize=18, fontweight='bold')
                
        # Content
        summary = self._generate_summary(vulnerabilities)
        overall_risk = self._calculate_overall_risk(summary)
        
        summary_text = f"""
Overall Risk Level: {overall_risk}

Key Findings:
• {summary['total_vulnerabilities']} total vulnerabilities identified
• {summary['by_severity'].get('critical', 0)} critical vulnerabilities require immediate attention
• {summary['hosts_affected']} systems affected

Recommended Actions:
• Address critical vulnerabilities within 24 hours
• Implement network segmentation for high-risk systems
• Establish regular vulnerability scanning schedule
• Update incident response procedures

Business Impact:
• Potential for data breach: {'High' if summary['by_severity'].get('critical', 0) > 0 else 'Medium'}
• Regulatory compliance risk: {self._calculate_overall_risk(summary)}
• Estimated remediation effort: {summary['total_vulnerabilities'] * 2} hours
"""
        
        ax.text(0.1, 0.85, summary_text, ha='left', va='top', fontsize=11,
               wrap=True, linespacing=1.5)
               
        pdf.savefig(fig)
        plt.close(fig)
        
    def _create_statistics_pages(self, pdf, vulnerabilities):
        """Create statistics pages with charts."""
        # Severity distribution pie chart
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(8.5, 11))
        
        summary = self._generate_summary(vulnerabilities)
        
        # Pie chart for severity
        severity_data = summary['by_severity']
        if severity_data:
            labels = list(severity_data.keys())
            sizes = list(severity_data.values())
            colors = {
                'critical': '#ff4444',
                'high': '#ff8844',
                'medium': '#ffaa44',
                'low': '#ffdd44',
                'info': '#cccccc'
            }
            pie_colors = [colors.get(label, '#999999') for label in labels]
            
            ax1.pie(sizes, labels=labels, colors=pie_colors, autopct='%1.1f%%')
            ax1.set_title('Vulnerabilities by Severity')
            
        # Risk distribution bar chart
        risk_data = summary['by_risk_level']
        if risk_data:
            labels = list(risk_data.keys())
            values = list(risk_data.values())
            
            ax2.bar(labels, values)
            ax2.set_title('Risk Level Distribution')
            ax2.set_xlabel('Risk Level')
            ax2.set_ylabel('Count')
            
        plt.tight_layout()
        pdf.savefig(fig)
        plt.close(fig)
        
    def _create_detailed_findings_pages(self, pdf, vulnerabilities):
        """Create detailed findings pages (simplified for space)."""
        # This would normally create multiple pages with detailed tables
        # For brevity, we'll create a summary table
        fig, ax = plt.subplots(figsize=(8.5, 11))
        ax.axis('off')
        
        ax.text(0.5, 0.95, 'Top Priority Vulnerabilities',
               ha='center', va='top', fontsize=16, fontweight='bold')
               
        # Table of top 10 vulnerabilities
        table_data = []
        headers = ['Host', 'Vulnerability', 'Risk Score', 'Priority']
        
        for vuln in vulnerabilities[:10]:
            risk_data = vuln.get('risk_assessment', {})
            table_data.append([
                vuln.get('host', 'N/A')[:15],
                vuln.get('name', 'Unknown')[:40] + '...',
                str(risk_data.get('risk_score', 'N/A')),
                str(risk_data.get('remediation_priority', 'N/A'))
            ])
            
        if table_data:
            table = ax.table(cellText=table_data, colLabels=headers,
                           cellLoc='left', loc='center')
            table.auto_set_font_size(False)
            table.set_fontsize(9)
            table.scale(1, 2)
            
        pdf.savefig(fig)
        plt.close(fig)
        
    def _create_recommendations_page(self, pdf, vulnerabilities):
        """Create recommendations page."""
        fig, ax = plt.subplots(figsize=(8.5, 11))
        ax.axis('off')
        
        ax.text(0.5, 0.95, 'Recommendations',
               ha='center', va='top', fontsize=18, fontweight='bold')
               
        recommendations = self._generate_overall_recommendations(vulnerabilities)
        
        y_position = 0.85
        for i, rec in enumerate(recommendations[:5]):  # Limit to top 5
            text = f"""
Priority: {rec['priority']}
Timeframe: {rec['timeframe']}
Actions:
"""
            for action in rec['actions']:
                text += f"  • {action}\n"
            text += f"Affected Systems: {rec['affected_systems']}\n"
            
            ax.text(0.1, y_position, text, ha='left', va='top', fontsize=10,
                   bbox=dict(boxstyle="round,pad=0.5", facecolor="lightblue"))
            y_position -= 0.15
            
        pdf.savefig(fig)
        plt.close(fig)


# Convenience functions for Claude Code orchestration

def score_vulnerabilities(vulnerabilities: List[Dict],
                        asset_criticality: Dict[str, int] = None,
                        environment_config: Dict = None) -> List[Dict]:
    """
    Add comprehensive risk scores to vulnerabilities.
    
    Args:
        vulnerabilities: List of vulnerabilities
        asset_criticality: Mapping of hosts to criticality scores (1-10)
        environment_config: Environmental configuration
        
    Returns:
        list: Vulnerabilities with risk assessments
        
    Example:
        >>> vulns = [{'host': '192.168.1.10', 'cvss_score': 7.5, ...}]
        >>> asset_crit = {'192.168.1.10': 8}  # Critical server
        >>> scored = score_vulnerabilities(vulns, asset_crit)
        >>> print(scored[0]['risk_assessment']['risk_score'])
    """
    scorer = RiskScorer()
    scored_vulns = []
    
    for vuln in vulnerabilities:
        host = vuln.get('host')
        asset_info = {'criticality': asset_criticality.get(host, 5)} if asset_criticality else None
        
        risk_assessment = scorer.calculate_risk_score(vuln, asset_info, environment_config)
        
        scored_vuln = vuln.copy()
        scored_vuln['risk_assessment'] = risk_assessment
        scored_vulns.append(scored_vuln)
        
    # Sort by remediation priority
    scored_vulns.sort(key=lambda x: x['risk_assessment']['remediation_priority'])
    
    return scored_vulns


def generate_vulnerability_report(vulnerabilities: List[Dict],
                                format: str = 'json',
                                **options) -> Union[Dict, str, bytes]:
    """
    Generate a vulnerability report in specified format.
    
    Args:
        vulnerabilities: List of vulnerabilities to report
        format: Report format (json, csv, pdf, html, executive)
        **options: Format-specific options
        
    Returns:
        Report in requested format
        
    Example:
        >>> report = generate_vulnerability_report(vulns, 'executive', 
        ...                                       client_name='Acme Corp')
        >>> print(report['executive_summary']['overall_risk_level'])
    """
    reporter = VulnerabilityReporter()
    return reporter.generate_report(vulnerabilities, format, options)


def prioritize_remediation(vulnerabilities: List[Dict],
                         max_effort_hours: int = 40) -> List[Dict]:
    """
    Create a prioritized remediation plan within effort constraints.
    
    Args:
        vulnerabilities: List of scored vulnerabilities
        max_effort_hours: Maximum effort hours available
        
    Returns:
        list: Prioritized remediation plan
        
    Example:
        >>> plan = prioritize_remediation(scored_vulns, max_effort_hours=20)
        >>> for item in plan:
        ...     print(f"Fix {item['vulnerability']['name']} - {item['effort_hours']}h")
    """
    plan = []
    total_hours = 0
    
    # Assume already sorted by priority
    for vuln in vulnerabilities:
        priority = vuln.get('risk_assessment', {}).get('remediation_priority', 5)
        
        # Estimate effort based on priority
        if priority == 1:
            effort = 4  # Critical vulnerabilities take more time
        elif priority == 2:
            effort = 3
        elif priority == 3:
            effort = 2
        else:
            effort = 1
            
        if total_hours + effort <= max_effort_hours:
            plan.append({
                'vulnerability': vuln,
                'effort_hours': effort,
                'cumulative_hours': total_hours + effort
            })
            total_hours += effort
        else:
            break
            
    return plan