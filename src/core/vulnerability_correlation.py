"""
Vulnerability Correlation Engine

This module provides functions to correlate vulnerability findings from multiple scanners,
match them with CVE database entries, and eliminate duplicates for Claude Code orchestration.
"""

import re
from typing import Dict, List, Optional, Any, Set, Tuple
from datetime import datetime
import hashlib
from difflib import SequenceMatcher

from ..diagnostics.cve_database import search_cve_by_id, search_cves_by_keyword
from ..utils.logger import get_logger

logger = get_logger(__name__)


class VulnerabilityCorrelator:
    """
    Correlates vulnerabilities from multiple sources and eliminates duplicates.
    """
    
    def __init__(self, confidence_threshold: float = 0.75):
        """
        Initialize the correlator.
        
        Args:
            confidence_threshold: Minimum confidence score for correlation (0-1)
        """
        self.confidence_threshold = confidence_threshold
        self.cve_pattern = re.compile(r'CVE-\d{4}-\d{4,}')
        
    def correlate_findings(self, scanner_results: Dict[str, List[Dict]]) -> Dict[str, Any]:
        """
        Correlate vulnerability findings from multiple scanners.
        
        Args:
            scanner_results: Dictionary mapping scanner names to their results
            
        Returns:
            dict: Correlated and deduplicated vulnerabilities
            
        Example:
            >>> results = {
            ...     'openvas': [{'name': 'Apache vuln', 'cve': 'CVE-2021-44228', ...}],
            ...     'nessus': [{'name': 'Log4j RCE', 'cve': ['CVE-2021-44228'], ...}]
            ... }
            >>> correlated = correlator.correlate_findings(results)
        """
        # Flatten all vulnerabilities from all scanners
        all_vulns = []
        for scanner, vulns in scanner_results.items():
            for vuln in vulns:
                vuln['_scanner'] = scanner
                all_vulns.append(vuln)
                
        # Group vulnerabilities by host and port
        host_vulns = self._group_by_host_port(all_vulns)
        
        # Correlate and deduplicate
        correlated_vulns = []
        for (host, port), vulns in host_vulns.items():
            deduped = self._deduplicate_vulnerabilities(vulns)
            for vuln in deduped:
                vuln['correlation_id'] = self._generate_correlation_id(vuln)
                correlated_vulns.append(vuln)
                
        # Match with CVE database
        enriched_vulns = self._enrich_with_cve_data(correlated_vulns)
        
        # Calculate summary statistics
        summary = self._calculate_summary(enriched_vulns, scanner_results)
        
        return {
            'correlated_vulnerabilities': enriched_vulns,
            'summary': summary,
            'correlation_metadata': {
                'confidence_threshold': self.confidence_threshold,
                'scanners_used': list(scanner_results.keys()),
                'correlation_time': datetime.now().isoformat()
            }
        }
        
    def _group_by_host_port(self, vulnerabilities: List[Dict]) -> Dict[Tuple[str, int], List[Dict]]:
        """Group vulnerabilities by host and port."""
        grouped = {}
        
        for vuln in vulnerabilities:
            host = vuln.get('host', 'unknown')
            port = int(vuln.get('port', 0))
            key = (host, port)
            
            if key not in grouped:
                grouped[key] = []
            grouped[key].append(vuln)
            
        return grouped
        
    def _deduplicate_vulnerabilities(self, vulnerabilities: List[Dict]) -> List[Dict]:
        """
        Deduplicate vulnerabilities based on various matching criteria.
        
        Args:
            vulnerabilities: List of vulnerabilities from possibly different scanners
            
        Returns:
            list: Deduplicated vulnerabilities with merged information
        """
        if len(vulnerabilities) <= 1:
            return vulnerabilities
            
        # Group by potential duplicates
        groups = []
        processed = set()
        
        for i, vuln1 in enumerate(vulnerabilities):
            if i in processed:
                continue
                
            group = [vuln1]
            processed.add(i)
            
            for j, vuln2 in enumerate(vulnerabilities[i+1:], i+1):
                if j in processed:
                    continue
                    
                confidence = self._calculate_similarity(vuln1, vuln2)
                if confidence >= self.confidence_threshold:
                    group.append(vuln2)
                    processed.add(j)
                    
            groups.append(group)
            
        # Merge each group into a single vulnerability
        deduplicated = []
        for group in groups:
            merged = self._merge_vulnerabilities(group)
            deduplicated.append(merged)
            
        return deduplicated
        
    def _calculate_similarity(self, vuln1: Dict, vuln2: Dict) -> float:
        """
        Calculate similarity score between two vulnerabilities.
        
        Returns:
            float: Similarity score (0-1)
        """
        score = 0.0
        weights = {
            'cve_match': 0.4,
            'name_similarity': 0.3,
            'description_similarity': 0.2,
            'severity_match': 0.1
        }
        
        # CVE matching
        cves1 = self._extract_cves(vuln1)
        cves2 = self._extract_cves(vuln2)
        if cves1 and cves2 and cves1.intersection(cves2):
            score += weights['cve_match']
            
        # Name similarity
        name1 = vuln1.get('name', '')
        name2 = vuln2.get('name', '')
        if name1 and name2:
            name_sim = SequenceMatcher(None, name1.lower(), name2.lower()).ratio()
            score += weights['name_similarity'] * name_sim
            
        # Description similarity
        desc1 = vuln1.get('description', '')
        desc2 = vuln2.get('description', '')
        if desc1 and desc2:
            desc_sim = SequenceMatcher(None, desc1[:200].lower(), desc2[:200].lower()).ratio()
            score += weights['description_similarity'] * desc_sim
            
        # Severity matching
        sev1 = self._normalize_severity(vuln1)
        sev2 = self._normalize_severity(vuln2)
        if sev1 == sev2:
            score += weights['severity_match']
            
        return score
        
    def _extract_cves(self, vulnerability: Dict) -> Set[str]:
        """Extract all CVE IDs from a vulnerability record."""
        cves = set()
        
        # Check various fields where CVEs might be stored
        cve_fields = ['cve', 'cve_id', 'cves', 'references']
        
        for field in cve_fields:
            value = vulnerability.get(field)
            if value:
                if isinstance(value, str):
                    cves.update(self.cve_pattern.findall(value))
                elif isinstance(value, list):
                    for item in value:
                        if isinstance(item, str):
                            cves.update(self.cve_pattern.findall(item))
                            
        return cves
        
    def _normalize_severity(self, vulnerability: Dict) -> str:
        """Normalize severity to common scale."""
        severity_fields = ['severity', 'severity_label', 'risk_factor']
        
        for field in severity_fields:
            value = vulnerability.get(field)
            if value:
                if isinstance(value, str):
                    value_lower = value.lower()
                    if 'critical' in value_lower:
                        return 'CRITICAL'
                    elif 'high' in value_lower:
                        return 'HIGH'
                    elif 'medium' in value_lower or 'moderate' in value_lower:
                        return 'MEDIUM'
                    elif 'low' in value_lower:
                        return 'LOW'
                    else:
                        return 'INFO'
                elif isinstance(value, (int, float)):
                    # Assume CVSS score
                    if value >= 9.0:
                        return 'CRITICAL'
                    elif value >= 7.0:
                        return 'HIGH'
                    elif value >= 4.0:
                        return 'MEDIUM'
                    elif value > 0:
                        return 'LOW'
                        
        return 'UNKNOWN'
        
    def _merge_vulnerabilities(self, group: List[Dict]) -> Dict[str, Any]:
        """
        Merge a group of duplicate vulnerabilities into one.
        
        Args:
            group: List of similar vulnerabilities
            
        Returns:
            dict: Merged vulnerability with combined information
        """
        if len(group) == 1:
            return group[0].copy()
            
        # Start with the first vulnerability as base
        merged = group[0].copy()
        
        # Track which scanners found this vulnerability
        scanners = [vuln.get('_scanner', 'unknown') for vuln in group]
        merged['detected_by'] = list(set(scanners))
        merged['detection_count'] = len(scanners)
        
        # Merge CVEs
        all_cves = set()
        for vuln in group:
            all_cves.update(self._extract_cves(vuln))
        merged['cve'] = sorted(list(all_cves))
        
        # Use highest severity
        severities = [self._normalize_severity(vuln) for vuln in group]
        severity_priority = ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'INFO', 'UNKNOWN']
        for sev in severity_priority:
            if sev in severities:
                merged['severity'] = sev
                break
                
        # Merge CVSS scores (use highest)
        cvss_scores = []
        for vuln in group:
            score = vuln.get('cvss_score') or vuln.get('cvss_v3_score') or vuln.get('cvss_base')
            if score:
                try:
                    cvss_scores.append(float(score))
                except:
                    pass
        if cvss_scores:
            merged['cvss_score'] = max(cvss_scores)
            
        # Combine solutions
        solutions = []
        for vuln in group:
            solution = vuln.get('solution')
            if solution and solution not in solutions:
                solutions.append(solution)
        if solutions:
            merged['solution'] = '\n\n'.join(solutions)
            
        # Combine references
        references = set()
        for vuln in group:
            refs = vuln.get('references', [])
            if isinstance(refs, list):
                references.update(refs)
            elif isinstance(refs, str):
                references.add(refs)
        merged['references'] = sorted(list(references))
        
        # Add correlation confidence
        merged['correlation_confidence'] = 'high' if len(group) > 2 else 'medium'
        
        return merged
        
    def _generate_correlation_id(self, vulnerability: Dict) -> str:
        """Generate unique correlation ID for a vulnerability."""
        # Create ID based on host, port, and vulnerability characteristics
        components = [
            vulnerability.get('host', 'unknown'),
            str(vulnerability.get('port', 0)),
            vulnerability.get('severity', 'unknown'),
            ','.join(vulnerability.get('cve', []))
        ]
        
        id_string = '|'.join(components)
        return hashlib.md5(id_string.encode()).hexdigest()[:12]
        
    def _enrich_with_cve_data(self, vulnerabilities: List[Dict]) -> List[Dict]:
        """
        Enrich vulnerabilities with data from CVE database.
        
        Args:
            vulnerabilities: List of correlated vulnerabilities
            
        Returns:
            list: Enriched vulnerabilities
        """
        enriched = []
        
        for vuln in vulnerabilities:
            enriched_vuln = vuln.copy()
            cves = vuln.get('cve', [])
            
            if cves:
                # Try to get data for the first CVE
                cve_data = search_cve_by_id(cves[0])
                
                if cve_data:
                    # Add CVE database information
                    enriched_vuln['cve_data'] = {
                        'description': cve_data.get('description'),
                        'published_date': cve_data.get('published_date'),
                        'last_modified': cve_data.get('last_modified_date'),
                        'cwe_ids': cve_data.get('cwe_ids', []),
                        'cvss_vector': cve_data.get('cvss_v3_vector')
                    }
                    
                    # Update CVSS score if not present
                    if 'cvss_score' not in enriched_vuln and cve_data.get('cvss_v3_score'):
                        enriched_vuln['cvss_score'] = cve_data['cvss_v3_score']
                        
            enriched.append(enriched_vuln)
            
        return enriched
        
    def _calculate_summary(self, vulnerabilities: List[Dict], 
                          original_results: Dict[str, List[Dict]]) -> Dict[str, Any]:
        """Calculate summary statistics for correlation results."""
        total_original = sum(len(vulns) for vulns in original_results.values())
        
        severity_counts = {
            'critical': 0,
            'high': 0,
            'medium': 0,
            'low': 0,
            'info': 0,
            'unknown': 0
        }
        
        hosts_affected = set()
        cves_found = set()
        
        for vuln in vulnerabilities:
            # Count by severity
            severity = vuln.get('severity', 'UNKNOWN').lower()
            if severity in severity_counts:
                severity_counts[severity] += 1
            else:
                severity_counts['unknown'] += 1
                
            # Collect unique hosts
            hosts_affected.add(vuln.get('host'))
            
            # Collect unique CVEs
            cves_found.update(vuln.get('cve', []))
            
        return {
            'total_findings': len(vulnerabilities),
            'original_findings': total_original,
            'deduplication_ratio': 1 - (len(vulnerabilities) / total_original) if total_original > 0 else 0,
            'by_severity': severity_counts,
            'hosts_affected': len(hosts_affected),
            'unique_cves': len(cves_found),
            'scanners_used': list(original_results.keys())
        }


class FuzzyMatcher:
    """
    Fuzzy matching for vulnerabilities without direct CVE references.
    """
    
    def __init__(self):
        self.keyword_patterns = {
            'sql_injection': ['sql injection', 'sqli', 'sql inject'],
            'xss': ['cross-site scripting', 'xss', 'cross site'],
            'rce': ['remote code execution', 'rce', 'command injection'],
            'lfi': ['local file inclusion', 'lfi', 'file include'],
            'xxe': ['xml external entity', 'xxe', 'xml injection'],
            'csrf': ['cross-site request forgery', 'csrf', 'xsrf'],
            'open_redirect': ['open redirect', 'url redirect', 'unvalidated redirect'],
            'ssrf': ['server-side request forgery', 'ssrf'],
            'dos': ['denial of service', 'dos', 'ddos'],
            'info_disclosure': ['information disclosure', 'info leak', 'data exposure']
        }
        
    def match_to_vulnerability_type(self, name: str, description: str) -> Optional[str]:
        """
        Match vulnerability to a type based on name and description.
        
        Args:
            name: Vulnerability name
            description: Vulnerability description
            
        Returns:
            str: Matched vulnerability type or None
        """
        combined_text = f"{name} {description}".lower()
        
        for vuln_type, patterns in self.keyword_patterns.items():
            for pattern in patterns:
                if pattern in combined_text:
                    return vuln_type
                    
        return None
        
    def find_similar_cves(self, vulnerability: Dict, limit: int = 5) -> List[Dict]:
        """
        Find similar CVEs based on vulnerability characteristics.
        
        Args:
            vulnerability: Vulnerability without CVE reference
            limit: Maximum CVEs to return
            
        Returns:
            list: Similar CVEs from database
        """
        # Extract key terms from vulnerability
        name = vulnerability.get('name', '')
        description = vulnerability.get('description', '')
        
        # Identify vulnerability type
        vuln_type = self.match_to_vulnerability_type(name, description)
        
        # Search for CVEs
        search_terms = []
        
        # Add vulnerability type as search term
        if vuln_type:
            search_terms.append(vuln_type.replace('_', ' '))
            
        # Extract product/service names
        # Simple heuristic: look for capitalized words
        words = (name + ' ' + description).split()
        for word in words:
            if word and word[0].isupper() and len(word) > 3:
                search_terms.append(word)
                
        # Search CVE database
        similar_cves = []
        for term in search_terms[:3]:  # Limit searches
            results = search_cves_by_keyword(term, limit=limit)
            similar_cves.extend(results)
            
        # Deduplicate and limit results
        seen_ids = set()
        unique_cves = []
        for cve in similar_cves:
            if cve['cve_id'] not in seen_ids:
                seen_ids.add(cve['cve_id'])
                unique_cves.append(cve)
                if len(unique_cves) >= limit:
                    break
                    
        return unique_cves


# Convenience functions for Claude Code orchestration

def correlate_scanner_results(scanner_results: Dict[str, List[Dict]],
                            confidence_threshold: float = 0.75) -> Dict[str, Any]:
    """
    Correlate vulnerability findings from multiple scanners.
    
    Args:
        scanner_results: Dictionary mapping scanner names to their results
        confidence_threshold: Minimum confidence for correlation (0-1)
        
    Returns:
        dict: Correlated and deduplicated vulnerabilities
        
    Example:
        >>> results = {
        ...     'openvas': openvas_results,
        ...     'nessus': nessus_results,
        ...     'qualys': qualys_results
        ... }
        >>> correlated = correlate_scanner_results(results)
        >>> print(f"Reduced {correlated['summary']['original_findings']} to {correlated['summary']['total_findings']} unique vulnerabilities")
    """
    correlator = VulnerabilityCorrelator(confidence_threshold)
    return correlator.correlate_findings(scanner_results)


def find_related_cves(vulnerability: Dict, max_results: int = 10) -> List[Dict]:
    """
    Find CVEs related to a vulnerability without direct CVE reference.
    
    Args:
        vulnerability: Vulnerability information
        max_results: Maximum CVEs to return
        
    Returns:
        list: Related CVEs
        
    Example:
        >>> vuln = {'name': 'SQL Injection in Login Form', 'description': '...'}
        >>> related = find_related_cves(vuln)
        >>> for cve in related:
        ...     print(f"{cve['cve_id']}: {cve['description'][:100]}...")
    """
    matcher = FuzzyMatcher()
    return matcher.find_similar_cves(vulnerability, limit=max_results)


def calculate_risk_priority(correlated_results: Dict[str, Any]) -> List[Dict]:
    """
    Calculate risk priority for correlated vulnerabilities.
    
    Args:
        correlated_results: Output from correlate_scanner_results
        
    Returns:
        list: Vulnerabilities sorted by risk priority
    """
    vulnerabilities = correlated_results.get('correlated_vulnerabilities', [])
    
    # Calculate priority score for each vulnerability
    for vuln in vulnerabilities:
        # Base score on CVSS
        cvss = vuln.get('cvss_score', 0)
        priority_score = cvss * 10
        
        # Boost for multiple scanner detections
        detection_count = vuln.get('detection_count', 1)
        if detection_count > 1:
            priority_score *= (1 + (detection_count - 1) * 0.1)
            
        # Boost for known exploits (check CVE data)
        cve_data = vuln.get('cve_data', {})
        if 'exploit' in cve_data.get('description', '').lower():
            priority_score *= 1.5
            
        # Boost for critical services
        port = vuln.get('port', 0)
        critical_ports = [22, 23, 3389, 445, 1433, 3306, 5432]  # SSH, Telnet, RDP, SMB, DBs
        if port in critical_ports:
            priority_score *= 1.2
            
        vuln['risk_priority_score'] = round(priority_score, 2)
        
    # Sort by priority score
    vulnerabilities.sort(key=lambda x: x.get('risk_priority_score', 0), reverse=True)
    
    return vulnerabilities