"""
Vulnerability Reporting Module

This module provides modular functions for generating customized vulnerability reports
that Claude Code can orchestrate based on assessment results.
"""

import json
import csv
from datetime import datetime
from typing import Dict, List, Optional, Any, Union
from io import StringIO
import html

from ..utils.logger import get_logger

logger = get_logger(__name__)


# Report generation functions
def generate_executive_summary(vulnerabilities: List[Dict[str, Any]], 
                             scan_metadata: Dict[str, Any] = None) -> str:
    """
    Generate an executive summary of vulnerabilities.
    
    Args:
        vulnerabilities: List of vulnerability findings
        scan_metadata: Metadata about the scan (target, date, etc.)
        
    Returns:
        str: Executive summary in plain text
        
    Example:
        >>> summary = generate_executive_summary(vulns, {'target': '192.168.1.1'})
        >>> print(summary)
    """
    # Count by severity
    severity_counts = {
        'CRITICAL': 0,
        'HIGH': 0,
        'MEDIUM': 0,
        'LOW': 0,
        'INFO': 0
    }
    
    for vuln in vulnerabilities:
        severity = vuln.get('severity', vuln.get('risk_level', 'INFO')).upper()
        if severity in severity_counts:
            severity_counts[severity] += 1
            
    # Generate summary
    summary = []
    summary.append("EXECUTIVE SUMMARY")
    summary.append("=" * 60)
    
    if scan_metadata:
        summary.append(f"Target: {scan_metadata.get('target', 'N/A')}")
        summary.append(f"Scan Date: {scan_metadata.get('scan_date', datetime.now().strftime('%Y-%m-%d'))}")
        summary.append(f"Scan Type: {scan_metadata.get('scan_type', 'Security Assessment')}")
        summary.append("")
    
    summary.append("VULNERABILITY OVERVIEW")
    summary.append("-" * 30)
    summary.append(f"Total Vulnerabilities: {len(vulnerabilities)}")
    summary.append("")
    summary.append("By Severity:")
    for severity, count in severity_counts.items():
        if count > 0:
            summary.append(f"  {severity}: {count}")
            
    # Risk assessment
    risk_score = calculate_overall_risk(vulnerabilities)
    summary.append("")
    summary.append(f"Overall Risk Score: {risk_score['score']}/10 ({risk_score['level']})")
    
    # Key findings
    critical_vulns = [v for v in vulnerabilities 
                     if v.get('severity', v.get('risk_level', '')).upper() == 'CRITICAL']
    
    if critical_vulns:
        summary.append("")
        summary.append("CRITICAL FINDINGS:")
        for vuln in critical_vulns[:3]:  # Top 3
            summary.append(f"  • {vuln.get('issue', vuln.get('description', 'Security vulnerability'))}")
            
    # Recommendations
    summary.append("")
    summary.append("KEY RECOMMENDATIONS:")
    recommendations = generate_prioritized_recommendations(vulnerabilities)
    for i, rec in enumerate(recommendations[:5], 1):
        summary.append(f"  {i}. {rec}")
        
    return "\n".join(summary)


def generate_detailed_findings(vulnerabilities: List[Dict[str, Any]], 
                             include_evidence: bool = True,
                             group_by: str = 'severity') -> str:
    """
    Generate detailed vulnerability findings report.
    
    Args:
        vulnerabilities: List of vulnerability findings
        include_evidence: Whether to include evidence/details
        group_by: How to group findings ('severity', 'service', 'type')
        
    Returns:
        str: Detailed findings report
    """
    report = []
    report.append("DETAILED VULNERABILITY FINDINGS")
    report.append("=" * 60)
    report.append(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    report.append("")
    
    # Group vulnerabilities
    grouped = {}
    for vuln in vulnerabilities:
        if group_by == 'severity':
            key = vuln.get('severity', vuln.get('risk_level', 'INFO')).upper()
        elif group_by == 'service':
            key = vuln.get('service', 'Unknown Service')
        elif group_by == 'type':
            key = vuln.get('type', 'vulnerability')
        else:
            key = 'Other'
            
        if key not in grouped:
            grouped[key] = []
        grouped[key].append(vuln)
        
    # Sort groups by severity if grouping by severity
    if group_by == 'severity':
        severity_order = ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'INFO']
        sorted_keys = [k for k in severity_order if k in grouped]
        sorted_keys.extend([k for k in grouped if k not in severity_order])
    else:
        sorted_keys = sorted(grouped.keys())
        
    # Generate report for each group
    for group_key in sorted_keys:
        group_vulns = grouped[group_key]
        
        report.append("")
        report.append(f"{group_key} ({len(group_vulns)} findings)")
        report.append("-" * 60)
        
        for i, vuln in enumerate(group_vulns, 1):
            report.append(f"\n{i}. {_format_vulnerability_detail(vuln, include_evidence)}")
            
    return "\n".join(report)


def _format_vulnerability_detail(vuln: Dict[str, Any], include_evidence: bool) -> str:
    """Format a single vulnerability detail."""
    lines = []
    
    # Title/Issue
    title = vuln.get('issue', vuln.get('description', 'Vulnerability'))
    if vuln.get('cve_id'):
        title = f"{vuln['cve_id']}: {title}"
    lines.append(title)
    
    # Basic details
    if vuln.get('host'):
        lines.append(f"   Host: {vuln['host']}")
    if vuln.get('port'):
        lines.append(f"   Port: {vuln['port']}")
    if vuln.get('service'):
        lines.append(f"   Service: {vuln['service']}")
        
    # Severity and scores
    severity = vuln.get('severity', vuln.get('risk_level'))
    if severity:
        lines.append(f"   Severity: {severity}")
    if vuln.get('cvss_score'):
        lines.append(f"   CVSS Score: {vuln['cvss_score']}")
        
    # Evidence
    if include_evidence:
        if vuln.get('evidence'):
            lines.append(f"   Evidence: {vuln['evidence']}")
        if vuln.get('banner'):
            lines.append(f"   Banner: {vuln['banner']}")
            
    # Recommendation
    if vuln.get('recommendation'):
        lines.append(f"   Recommendation: {vuln['recommendation']}")
        
    return "\n".join(lines)


def generate_remediation_plan(vulnerabilities: List[Dict[str, Any]], 
                            timeline_days: int = 30) -> str:
    """
    Generate a prioritized remediation plan.
    
    Args:
        vulnerabilities: List of vulnerability findings
        timeline_days: Total days for remediation timeline
        
    Returns:
        str: Remediation plan with timeline
    """
    plan = []
    plan.append("VULNERABILITY REMEDIATION PLAN")
    plan.append("=" * 60)
    plan.append(f"Timeline: {timeline_days} days")
    plan.append(f"Start Date: {datetime.now().strftime('%Y-%m-%d')}")
    plan.append("")
    
    # Prioritize vulnerabilities
    prioritized = prioritize_vulnerabilities(vulnerabilities)
    
    # Phase 1: Critical (Days 1-7)
    critical = [v for v in prioritized if v['priority'] == 'immediate']
    if critical:
        plan.append("PHASE 1: IMMEDIATE ACTION (Days 1-7)")
        plan.append("-" * 40)
        for vuln in critical:
            plan.append(_format_remediation_item(vuln))
            
    # Phase 2: High Priority (Days 8-14)
    high = [v for v in prioritized if v['priority'] == 'high']
    if high:
        plan.append("\nPHASE 2: HIGH PRIORITY (Days 8-14)")
        plan.append("-" * 40)
        for vuln in high:
            plan.append(_format_remediation_item(vuln))
            
    # Phase 3: Medium Priority (Days 15-21)
    medium = [v for v in prioritized if v['priority'] == 'medium']
    if medium:
        plan.append("\nPHASE 3: MEDIUM PRIORITY (Days 15-21)")
        plan.append("-" * 40)
        for vuln in medium:
            plan.append(_format_remediation_item(vuln))
            
    # Phase 4: Low Priority (Days 22-30)
    low = [v for v in prioritized if v['priority'] == 'low']
    if low:
        plan.append("\nPHASE 4: LOW PRIORITY (Days 22-30)")
        plan.append("-" * 40)
        for vuln in low:
            plan.append(_format_remediation_item(vuln))
            
    # Summary
    plan.append("\n\nREMEDIATION SUMMARY")
    plan.append("-" * 40)
    plan.append(f"Total vulnerabilities to remediate: {len(vulnerabilities)}")
    plan.append(f"Critical/Immediate: {len(critical)}")
    plan.append(f"High Priority: {len(high)}")
    plan.append(f"Medium Priority: {len(medium)}")
    plan.append(f"Low Priority: {len(low)}")
    
    return "\n".join(plan)


def _format_remediation_item(vuln: Dict[str, Any]) -> str:
    """Format a single remediation item."""
    lines = []
    
    # Issue
    issue = vuln.get('issue', vuln.get('description', 'Vulnerability'))
    if vuln.get('host') and vuln.get('port'):
        lines.append(f"\n• {issue} ({vuln['host']}:{vuln['port']})")
    else:
        lines.append(f"\n• {issue}")
        
    # Action required
    if vuln.get('recommendation'):
        lines.append(f"  Action: {vuln['recommendation']}")
    else:
        lines.append(f"  Action: Investigate and remediate {vuln.get('type', 'vulnerability')}")
        
    # Effort estimate
    effort = _estimate_remediation_effort(vuln)
    lines.append(f"  Estimated Effort: {effort}")
    
    # Dependencies
    if vuln.get('dependencies'):
        lines.append(f"  Dependencies: {', '.join(vuln['dependencies'])}")
        
    return "\n".join(lines)


def _estimate_remediation_effort(vuln: Dict[str, Any]) -> str:
    """Estimate remediation effort for a vulnerability."""
    vuln_type = vuln.get('type', '')
    
    effort_map = {
        'weak_service': '2-4 hours (service replacement)',
        'ssl_issue': '1-2 hours (certificate update)',
        'default_credentials': '30 minutes (password change)',
        'open_port': '1 hour (firewall rule)',
        'missing_patch': '1-4 hours (patch installation)',
        'configuration': '1-2 hours (configuration change)'
    }
    
    return effort_map.get(vuln_type, '2-4 hours (investigation required)')


# Export functions for different formats
def export_as_json(vulnerabilities: List[Dict[str, Any]], 
                  metadata: Dict[str, Any] = None) -> str:
    """
    Export vulnerabilities as JSON.
    
    Args:
        vulnerabilities: List of vulnerability findings
        metadata: Additional metadata to include
        
    Returns:
        str: JSON formatted report
    """
    report = {
        'metadata': metadata or {},
        'summary': {
            'total_vulnerabilities': len(vulnerabilities),
            'by_severity': _count_by_severity(vulnerabilities),
            'generated_at': datetime.now().isoformat()
        },
        'vulnerabilities': vulnerabilities
    }
    
    return json.dumps(report, indent=2, default=str)


def export_as_csv(vulnerabilities: List[Dict[str, Any]]) -> str:
    """
    Export vulnerabilities as CSV.
    
    Args:
        vulnerabilities: List of vulnerability findings
        
    Returns:
        str: CSV formatted report
    """
    output = StringIO()
    
    # Determine all fields
    all_fields = set()
    for vuln in vulnerabilities:
        all_fields.update(vuln.keys())
        
    # Standard field order
    field_order = ['severity', 'host', 'port', 'service', 'type', 'issue', 
                   'cve_id', 'cvss_score', 'recommendation']
    
    # Add remaining fields
    remaining_fields = sorted(all_fields - set(field_order))
    fields = field_order + remaining_fields
    
    # Write CSV
    writer = csv.DictWriter(output, fieldnames=fields)
    writer.writeheader()
    
    for vuln in vulnerabilities:
        # Handle nested data
        flat_vuln = {}
        for field in fields:
            value = vuln.get(field, '')
            if isinstance(value, (list, dict)):
                flat_vuln[field] = json.dumps(value)
            else:
                flat_vuln[field] = value
        writer.writerow(flat_vuln)
        
    return output.getvalue()


def export_as_html(vulnerabilities: List[Dict[str, Any]], 
                  metadata: Dict[str, Any] = None,
                  include_charts: bool = True) -> str:
    """
    Export vulnerabilities as HTML report.
    
    Args:
        vulnerabilities: List of vulnerability findings
        metadata: Additional metadata to include
        include_charts: Whether to include visualization charts
        
    Returns:
        str: HTML formatted report
    """
    # HTML template
    html_parts = []
    
    # Header
    html_parts.append("""
<!DOCTYPE html>
<html>
<head>
    <title>Vulnerability Assessment Report</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        h1, h2, h3 { color: #333; }
        .critical { color: #d32f2f; }
        .high { color: #f57c00; }
        .medium { color: #fbc02d; }
        .low { color: #388e3c; }
        table { border-collapse: collapse; width: 100%; margin: 20px 0; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        .summary-box { background: #f5f5f5; padding: 15px; margin: 20px 0; border-radius: 5px; }
        .chart-container { width: 400px; height: 300px; display: inline-block; margin: 20px; }
    </style>
""")
    
    if include_charts:
        html_parts.append("""
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
""")
        
    html_parts.append("</head>\n<body>")
    
    # Title and metadata
    html_parts.append("<h1>Vulnerability Assessment Report</h1>")
    
    if metadata:
        html_parts.append('<div class="summary-box">')
        html_parts.append(f"<p><strong>Target:</strong> {html.escape(str(metadata.get('target', 'N/A')))}</p>")
        html_parts.append(f"<p><strong>Scan Date:</strong> {metadata.get('scan_date', datetime.now().strftime('%Y-%m-%d %H:%M'))}</p>")
        html_parts.append(f"<p><strong>Scan Type:</strong> {html.escape(str(metadata.get('scan_type', 'Security Assessment')))}</p>")
        html_parts.append("</div>")
        
    # Summary statistics
    severity_counts = _count_by_severity(vulnerabilities)
    html_parts.append("<h2>Summary</h2>")
    html_parts.append('<div class="summary-box">')
    html_parts.append(f"<p><strong>Total Vulnerabilities:</strong> {len(vulnerabilities)}</p>")
    
    for severity, count in severity_counts.items():
        if count > 0:
            html_parts.append(f'<p class="{severity.lower()}"><strong>{severity}:</strong> {count}</p>')
            
    html_parts.append("</div>")
    
    # Charts
    if include_charts and vulnerabilities:
        html_parts.append("<h2>Vulnerability Distribution</h2>")
        html_parts.append('<div class="chart-container">')
        html_parts.append('<canvas id="severityChart"></canvas>')
        html_parts.append('</div>')
        
    # Detailed findings table
    html_parts.append("<h2>Detailed Findings</h2>")
    html_parts.append("<table>")
    html_parts.append("<tr><th>Severity</th><th>Host</th><th>Port</th><th>Service</th><th>Issue</th><th>Recommendation</th></tr>")
    
    for vuln in sorted(vulnerabilities, key=lambda v: _severity_score(v), reverse=True):
        severity = vuln.get('severity', vuln.get('risk_level', 'INFO'))
        html_parts.append("<tr>")
        html_parts.append(f'<td class="{severity.lower()}">{html.escape(str(severity))}</td>')
        html_parts.append(f"<td>{html.escape(str(vuln.get('host', 'N/A')))}</td>")
        html_parts.append(f"<td>{html.escape(str(vuln.get('port', 'N/A')))}</td>")
        html_parts.append(f"<td>{html.escape(str(vuln.get('service', 'N/A')))}</td>")
        html_parts.append(f"<td>{html.escape(str(vuln.get('issue', vuln.get('description', 'N/A'))))}</td>")
        html_parts.append(f"<td>{html.escape(str(vuln.get('recommendation', 'Review and remediate')))}</td>")
        html_parts.append("</tr>")
        
    html_parts.append("</table>")
    
    # Chart JavaScript
    if include_charts and vulnerabilities:
        html_parts.append("""
<script>
const ctx = document.getElementById('severityChart').getContext('2d');
const severityChart = new Chart(ctx, {
    type: 'doughnut',
    data: {
        labels: %s,
        datasets: [{
            data: %s,
            backgroundColor: ['#d32f2f', '#f57c00', '#fbc02d', '#388e3c', '#1976d2']
        }]
    },
    options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
            title: {
                display: true,
                text: 'Vulnerabilities by Severity'
            }
        }
    }
});
</script>
""" % (
    json.dumps(list(severity_counts.keys())),
    json.dumps(list(severity_counts.values()))
))
    
    html_parts.append("</body>\n</html>")
    
    return "\n".join(html_parts)


# Helper functions
def _count_by_severity(vulnerabilities: List[Dict[str, Any]]) -> Dict[str, int]:
    """Count vulnerabilities by severity."""
    counts = {
        'CRITICAL': 0,
        'HIGH': 0,
        'MEDIUM': 0,
        'LOW': 0,
        'INFO': 0
    }
    
    for vuln in vulnerabilities:
        severity = vuln.get('severity', vuln.get('risk_level', 'INFO')).upper()
        if severity in counts:
            counts[severity] += 1
        else:
            counts['INFO'] += 1
            
    return counts


def _severity_score(vuln: Dict[str, Any]) -> int:
    """Get numeric score for severity sorting."""
    severity = vuln.get('severity', vuln.get('risk_level', 'INFO')).upper()
    scores = {
        'CRITICAL': 5,
        'HIGH': 4,
        'MEDIUM': 3,
        'LOW': 2,
        'INFO': 1
    }
    return scores.get(severity, 0)


def calculate_overall_risk(vulnerabilities: List[Dict[str, Any]]) -> Dict[str, Any]:
    """Calculate overall risk score based on vulnerabilities."""
    if not vulnerabilities:
        return {'score': 0, 'level': 'LOW'}
        
    # Weight by severity
    weights = {
        'CRITICAL': 10,
        'HIGH': 7,
        'MEDIUM': 4,
        'LOW': 2,
        'INFO': 1
    }
    
    total_score = 0
    for vuln in vulnerabilities:
        severity = vuln.get('severity', vuln.get('risk_level', 'INFO')).upper()
        total_score += weights.get(severity, 1)
        
    # Normalize to 0-10 scale
    max_possible = len(vulnerabilities) * 10
    normalized_score = min(10, (total_score / max_possible) * 10) if max_possible > 0 else 0
    
    # Determine risk level
    if normalized_score >= 8:
        level = 'CRITICAL'
    elif normalized_score >= 6:
        level = 'HIGH'
    elif normalized_score >= 4:
        level = 'MEDIUM'
    else:
        level = 'LOW'
        
    return {
        'score': round(normalized_score, 1),
        'level': level,
        'total_weighted': total_score
    }


def generate_prioritized_recommendations(vulnerabilities: List[Dict[str, Any]]) -> List[str]:
    """Generate prioritized recommendations based on findings."""
    recommendations = []
    
    # Check for critical issues
    critical = [v for v in vulnerabilities 
               if v.get('severity', v.get('risk_level', '')).upper() == 'CRITICAL']
    if critical:
        recommendations.append(f"Immediately address {len(critical)} critical vulnerabilities")
        
    # Check for specific vulnerability types
    vuln_types = {}
    for vuln in vulnerabilities:
        vuln_type = vuln.get('type', 'vulnerability')
        vuln_types[vuln_type] = vuln_types.get(vuln_type, 0) + 1
        
    # Type-specific recommendations
    if vuln_types.get('weak_service', 0) > 0:
        recommendations.append("Replace or secure weak/unencrypted services")
        
    if vuln_types.get('ssl_issue', 0) > 0:
        recommendations.append("Update SSL/TLS certificates and configurations")
        
    if vuln_types.get('default_credentials', 0) > 0:
        recommendations.append("Change all default credentials immediately")
        
    if vuln_types.get('open_port', 0) > 3:
        recommendations.append("Review and restrict unnecessary open ports")
        
    # General recommendations
    if not recommendations:
        recommendations.append("Perform regular vulnerability assessments")
        
    recommendations.append("Implement a vulnerability management program")
    recommendations.append("Keep all software and systems updated")
    
    return recommendations


def prioritize_vulnerabilities(vulnerabilities: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """Add priority field to vulnerabilities based on severity and impact."""
    prioritized = []
    
    for vuln in vulnerabilities:
        vuln_copy = vuln.copy()
        
        severity = vuln.get('severity', vuln.get('risk_level', 'INFO')).upper()
        
        # Determine priority
        if severity == 'CRITICAL':
            vuln_copy['priority'] = 'immediate'
        elif severity == 'HIGH':
            vuln_copy['priority'] = 'high'
        elif severity == 'MEDIUM':
            vuln_copy['priority'] = 'medium'
        else:
            vuln_copy['priority'] = 'low'
            
        # Adjust based on specific factors
        if vuln.get('type') == 'default_credentials':
            vuln_copy['priority'] = 'immediate'
        elif vuln.get('type') == 'weak_service' and vuln.get('port') in [23, 21]:
            vuln_copy['priority'] = 'immediate'
            
        prioritized.append(vuln_copy)
        
    # Sort by priority
    priority_order = {'immediate': 0, 'high': 1, 'medium': 2, 'low': 3}
    prioritized.sort(key=lambda v: priority_order.get(v['priority'], 99))
    
    return prioritized


# Comparison functions for tracking changes
def compare_scan_results(previous: List[Dict[str, Any]], 
                        current: List[Dict[str, Any]]) -> Dict[str, List[Dict[str, Any]]]:
    """
    Compare two sets of vulnerability scan results.
    
    Args:
        previous: Previous scan results
        current: Current scan results
        
    Returns:
        dict: Categorized differences (new, fixed, persistent)
    """
    # Create unique identifiers for vulnerabilities
    def vuln_key(v):
        return f"{v.get('host', '')}:{v.get('port', '')}:{v.get('type', '')}:{v.get('cve_id', '')}"
        
    previous_keys = {vuln_key(v): v for v in previous}
    current_keys = {vuln_key(v): v for v in current}
    
    # Find differences
    new_vulns = []
    fixed_vulns = []
    persistent_vulns = []
    
    # New vulnerabilities
    for key, vuln in current_keys.items():
        if key not in previous_keys:
            new_vulns.append(vuln)
        else:
            persistent_vulns.append(vuln)
            
    # Fixed vulnerabilities
    for key, vuln in previous_keys.items():
        if key not in current_keys:
            fixed_vulns.append(vuln)
            
    return {
        'new': new_vulns,
        'fixed': fixed_vulns,
        'persistent': persistent_vulns,
        'summary': {
            'new_count': len(new_vulns),
            'fixed_count': len(fixed_vulns),
            'persistent_count': len(persistent_vulns),
            'total_previous': len(previous),
            'total_current': len(current)
        }
    }


def generate_trend_report(scan_history: List[Dict[str, Any]]) -> str:
    """
    Generate a trend analysis report from multiple scans.
    
    Args:
        scan_history: List of scan results with dates
        
    Returns:
        str: Trend analysis report
    """
    report = []
    report.append("VULNERABILITY TREND ANALYSIS")
    report.append("=" * 60)
    
    if len(scan_history) < 2:
        report.append("Insufficient data for trend analysis (need at least 2 scans)")
        return "\n".join(report)
        
    # Sort by date
    sorted_scans = sorted(scan_history, key=lambda s: s.get('date', ''))
    
    # Analyze trends
    report.append(f"Analysis Period: {sorted_scans[0]['date']} to {sorted_scans[-1]['date']}")
    report.append(f"Total Scans: {len(sorted_scans)}")
    report.append("")
    
    # Track severity trends
    report.append("SEVERITY TRENDS")
    report.append("-" * 30)
    
    for scan in sorted_scans:
        counts = _count_by_severity(scan.get('vulnerabilities', []))
        total = sum(counts.values())
        report.append(f"\n{scan['date']}:")
        report.append(f"  Total: {total}")
        for severity, count in counts.items():
            if count > 0:
                report.append(f"  {severity}: {count}")
                
    # Calculate improvement
    first_scan = sorted_scans[0]['vulnerabilities']
    last_scan = sorted_scans[-1]['vulnerabilities']
    
    comparison = compare_scan_results(first_scan, last_scan)
    
    report.append("\n\nOVERALL PROGRESS")
    report.append("-" * 30)
    report.append(f"Vulnerabilities Fixed: {comparison['summary']['fixed_count']}")
    report.append(f"New Vulnerabilities: {comparison['summary']['new_count']}")
    report.append(f"Persistent Issues: {comparison['summary']['persistent_count']}")
    
    # Calculate improvement percentage
    if len(first_scan) > 0:
        improvement = ((len(first_scan) - len(last_scan)) / len(first_scan)) * 100
        report.append(f"\nOverall Improvement: {improvement:.1f}%")
        
    return "\n".join(report)